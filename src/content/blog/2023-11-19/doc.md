---
title: "C++指针知识大总结"
pubDate: "2023-11-19"
description: "C++学习了一段时间，对指针的使用变得频繁起来，本篇文章主要是梳理C++基础部分的指针使用，后续会随着学习的深入不断更新~~~"
heroImage: "http://localhost:4321/@fs/D:/code/Hope-second-try/src/theme-simple/assets/media/11.jpg?origWidth=2176&origHeight=1224&origFormat=jpg" 
tags: ["C++基础"]
---

## 目录
+ 指针概述
+ 指针的应用
***********************

## 指针概述
第一次接触指针的时候，老师告诉我们，顾名思义，指针的作用就是指向一个东西，那么计算机是怎么找到指针指向的地方的呢？是因为指针自己是个变量，存放着指向的对象的地址。而不同类型的指针只能指向和他类型相同的东西。由此我们形成了对指针的第一印象——*指针是一个存放着和他类型相同的东西的地址的东西*。有点奇怪，不过可以接受。

#####由此，我们可以得出一些指针的性质：
+ 所有指针所占的内存空间都是4个字节（针对32位机来说）

这一点很好理解，一个东西所占的内存空间是由他的内容决定的，而不论什么类型的指针寻访的都是地址，所以长度相同也就很好理解了。

+ 指向常量的指针变量、指针常量、指向常量的指针常量

``` bash
const  char *p;//“指向常量的指针变量”
char const *p;//“指向常量的指针变量”
char *const p;//“指针常量”
char const * const p;//“指向常量的指针常量”
const char * const p;//“指向常量的指针常量”
```
区分这以上三者主要是看 *const* 的位置。对于 *指向常量的指针变量* ，const约束的是* p，实际上是限制了指针对变量的写的权限，这也就引出了为什么说指针常量不能指向常量（这个问题在后面细嗦）；对于 *指针常量* ，const约束的是p，也就是指针本身，说明指针本身是个常量，它的内容只能在初始化时指定，对他进行“写”的操作都是不合法的;对于 *指向常量的指针常量* ，同时对指针本身和指针的内容都进行了约束，约束指针只能是可读的，要求不能通过指针修改指针所指向的内容。

看起来很奇怪的是 *指针常量不能指向常量* 。在指针运算中，我们强调指针对变量的操作权限只能与变量的特性一致或者比变量本身少，而不能放大权限。所以 *指向常量的指针变量* 可以指向变量。指针常量是可读不可写的，看似不可以通过指针去修改内容，但是可读的操作就使得可以读取内容并修改，这与“可读”并不矛盾。所以要指向常量，我们只能用指向常量的指针常量。

## 指针的应用
+ 数组
+ 链表

